# Fetching Module

Модуль **Чтения** (`FetchingExecutor`) отвечает за выполнение операций, не изменяющих состояние данных: `GET Object`, `HEAD Object` и `LIST Objects`. Он получает запрос и политику чтения от `Policy & Routing Engine`, взаимодействует с кэшем и S3-бэкендами, и возвращает запрошенные данные или метаданные.

## Основные возможности

- **Интеграция с кэшем**: Проверка наличия объекта в кэше перед обращением к бэкендам
- **Политики чтения**: Поддержка стратегий `first` и `newest` для GET/HEAD запросов
- **Слияние списков**: Объединение результатов LIST операций от всех бэкендов
- **Потоковая передача**: Передача данных от бэкенда к клиенту без буферизации
- **Сбор метрик**: Мониторинг производительности операций чтения
- **Обратная связь**: Уведомление Backend Manager о результатах операций

## Архитектура

### Зависимости

Модуль зависит от трех интерфейсов:

1. **BackendProvider** - для получения списка живых бэкендов и отправки обратной связи
2. **Cache** - для проверки наличия объектов в кэше
3. **Metrics** - для сбора метрик производительности

### Поддерживаемые операции

- `GetObject` - получение объекта с бэкенда
- `HeadObject` - получение метаданных объекта
- `HeadBucket` - проверка существования бакета
- `ListObjects` - получение списка объектов с слиянием результатов
- `ListBuckets` - получение списка бакетов
- `ListMultipartUploads` - получение списка активных multipart загрузок

## Стратегии чтения

### First Strategy (`strategy=first`)

Запускает параллельные запросы ко всем бэкендам и возвращает ответ от первого успешно ответившего. Остальные запросы отменяются.

**Применение:**
- Минимальная задержка ответа
- Подходит для случаев, когда важна скорость, а не актуальность данных

### Newest Strategy (`strategy=newest`)

Выполняется в три фазы:
1. **HEAD запросы** ко всем бэкендам для получения метаданных
2. **Сравнение Last-Modified** для выбора самого нового объекта
3. **GET/HEAD запрос** к бэкенду с самым новым объектом

**Применение:**
- Гарантия получения самой актуальной версии объекта
- Подходит для критически важных данных

## Слияние списков

Для операций LIST модуль:

1. Запускает параллельные запросы ко всем бэкендам
2. Собирает все результаты
3. Удаляет дубликаты по ключу, оставляя самую новую версию
4. Сортирует результаты по ключу
5. Формирует единый токен пагинации для всех бэкендов

## Пагинация

Модуль поддерживает сложную пагинацию через `ProxyContinuationToken`, который содержит токены продолжения для каждого бэкенда отдельно.

```json
{
  "backend_tokens": {
    "backend1": "token1",
    "backend2": "token2"
  }
}
```

## Потоковая передача

Для GET операций модуль:

1. Получает `io.ReadCloser` от S3 клиента
2. Оборачивает его в `bytesCountingReader` для подсчета байт
3. Передает напрямую в `S3Response.Body` без буферизации
4. Записывает метрику количества прочитанных байт при закрытии

## Сбор метрик

Модуль собирает следующие метрики:

- **Задержка запросов**: `ObserveBackendRequestLatency(backendID, operation, latency)`
- **Количество запросов**: `IncrementBackendRequestsTotal(backendID, operation, result)`
- **Объем данных**: `AddBackendBytesRead(backendID, bytes)`

## Обработка ошибок

- **Нет живых бэкендов**: возвращает `503 Service Unavailable`
- **Объект не найден**: возвращает `404 Not Found` если ни один бэкенд не вернул объект
- **Неизвестная стратегия**: возвращает `500 Internal Server Error`
- **Ошибки бэкендов**: передаются в Backend Manager через `ReportFailure`

## Использование

### Создание экземпляра

```go
import (
    "s3proxy/fetch"
    "s3proxy/backend"
    "s3proxy/monitoring"
)

// Создание зависимостей
backendManager := backend.NewManager(config)
cache := fetch.NewStubCache() // или реальная реализация кэша
metrics := monitoring.NewMetrics()

// Создание Fetcher
fetcher := fetch.NewFetcher(backendManager, cache, metrics)
```

### Выполнение операций

```go
// GET Object с стратегией "first"
policy := routing.ReadOperationPolicy{Strategy: "first"}
response := fetcher.GetObject(ctx, request, policy)

// HEAD Object с стратегией "newest"
policy = routing.ReadOperationPolicy{Strategy: "newest"}
response = fetcher.HeadObject(ctx, request, policy)

// LIST Objects
response = fetcher.ListObjects(ctx, request)
```

## Тестирование

Модуль включает полный набор unit тестов с мокированием всех зависимостей:

```bash
go test -v ./fetch/
```

Тесты покрывают:
- Работу с кэшем (hit/miss)
- Обе стратегии чтения (first/newest)
- Слияние результатов LIST операций
- Обработку ошибок
- Сбор метрик
- Потоковую передачу данных

## Заглушка кэша

Для разработки и тестирования предоставляется `StubCache`, который всегда возвращает "не найдено":

```go
cache := fetch.NewStubCache()
fetcher := fetch.NewFetcher(backendManager, cache, metrics)
```

## Интеграция

Модуль реализует интерфейс `routing.FetchingExecutor` и может быть легко интегрирован в `Policy & Routing Engine`:

```go
type Engine struct {
    fetcher routing.FetchingExecutor
    // ...
}

func (e *Engine) handleGetObject(req *apigw.S3Request) *apigw.S3Response {
    policy := e.config.Policies.Get
    return e.fetcher.GetObject(req.Context, req, policy)
}
```

## Производительность

- **Параллельные запросы**: Все запросы к бэкендам выполняются параллельно
- **Отмена запросов**: Неиспользуемые запросы отменяются через context
- **Потоковая передача**: Данные передаются без буферизации в памяти
- **Минимальные аллокации**: Переиспользование структур данных где возможно

## Ограничения

- Кэш используется только для чтения, модуль не наполняет кэш
- Поддерживается только базовая пагинация для LIST операций
- Слияние списков может быть ресурсоемким при большом количестве объектов
- Стратегия "newest" требует дополнительных HEAD запросов
