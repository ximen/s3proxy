---

### Техническое Задание: Модуль Чтения (Fetching Module)

#### 1. Назначение и Зона ответственности

Модуль **Чтения** (`FetchingExecutor`) отвечает за выполнение операций, не изменяющих состояние данных: `GET Object`, `HEAD Object` и `LIST Objects`. Он получает запрос и политику чтения от `Policy & Routing Engine`, взаимодействует с кэшем и S3-бэкендами, и возвращает запрошенные данные или метаданные.

**Ключевые обязанности:**
*   **Реализация интерфейса `FetchingExecutor`**.
*   **Интеграция с кэшем**: Перед обращением к бэкендам всегда проверять наличие запрашиваемого объекта в кэше через стандартизированный интерфейс `Cache`. Модуль **не наполняет** кэш, а только читает из него.
*   **Реализация политик чтения (`strategy=first`, `strategy=newest`)** для `GET`/`HEAD` запросов.
*   **Реализация слияния списков (`LIST`)** с корректной обработкой пагинации.
*   **Обеспечение потоковой передачи (`streaming`)** тела объекта от бэкенда до клиента без полной буферизации в памяти прокси.
*   **Взаимодействие с `Backend Manager`**: Запрос актуального списка "живых" бэкендов и отправка обратной связи (`ReportSuccess`/`ReportFailure`) по результатам операций.
*   **Сбор и экспорт метрик**, связанных с операциями чтения на бэкендах (задержки, количество запросов, объем данных).

**Вне зоны ответственности модуля:**
*   Наполнение или инвалидация кэша (это делают другие модули).
*   Логика работы кэша (in-memory, Redis) и сбор метрик кэша (`hit/miss`).
*   Принятие решений о том, какую политику чтения использовать.

#### 2. Зависимости и Интерфейсы

Модуль будет зависеть от трех четко определенных интерфейсов: `BackendProvider`, `Cache` и `Metrics`.

```go
// 1. Интерфейс для получения списка бэкендов (определяется и реализуется в BackendManager)
type BackendProvider interface {
    GetLiveBackends() []*Backend
    ReportSuccess(backendID string)
    ReportFailure(backendID string, err error)
}

// 2. Интерфейс для взаимодействия с кэшем (определяется здесь, реализуется в CacheModule)
type Cache interface {
    // Get ищет объект в кэше. Если нашел, возвращает готовый для отправки S3Response.
    Get(bucket, key string) (response *S3Response, found bool)
}

// 3. Структура для метрик (определяется и реализуется в MonitoringModule)
type Metrics interface {
    // Методы для обновления метрик, специфичных для Fetching-операций.
    ObserveBackendRequestLatency(backendID, operation string, latency float64)
    IncrementBackendRequestsTotal(backendID, operation, result string)
    AddBackendBytesRead(backendID string, bytes int64)
}

// Основная структура модуля
type Fetcher struct {
    backendProvider BackendProvider
    cache           Cache
    metrics         Metrics
    // ... логгер
}

// Конструктор
func NewFetcher(provider BackendProvider, cache Cache, metrics Metrics) *Fetcher {
    return &Fetcher{
        backendProvider: provider,
        cache:           cache,
        metrics:         metrics,
    }
}
```

#### 3. Временная Заглушка для Модуля Кэша

На время разработки, пока полноценный `CacheModule` не готов, будет использоваться простая заглушка (`stub`), которая реализует интерфейс `Cache`, но ничего не делает. Это позволит скомпилировать и протестировать `Fetcher` независимо.

```go
// Файл: cache/stub.go

package cache

// StubCache - это заглушка, реализующая интерфейс Cache.
// Она всегда сообщает, что в кэше ничего нет.
type StubCache struct{}

// NewStubCache создает новую заглушку.
func NewStubCache() *StubCache {
    return &StubCache{}
}

// Get для заглушки всегда возвращает "не найдено".
func (s *StubCache) Get(bucket, key string) (*S3Response, bool) {
    return nil, false
}

// В main.go при инициализации:
// cacheModule := cache.NewStubCache()
// fetcher := NewFetcher(backendManager, cacheModule, metrics)
```

#### 4. Детальная логика операций

**A. `GetObject(ctx, req, policy)` и `HeadObject(ctx, req, policy)`**

1.  **Проверка кэша**: Вызвать `f.cache.Get(req.Bucket, req.Key)`.
2.  Если `found == true`, немедленно вернуть полученный `response`.
3.  Если `found == false` (что всегда будет при использовании `StubCache`), перейти к работе с бэкендами:
    a. Запросить "живые" бэкенды у `f.backendProvider`. Если их нет, вернуть ошибку `503 Service Unavailable`.
    b. **В зависимости от `policy.Strategy`**:
        *   **`"first"`**:
            i. Запустить параллельные `GET`/`HEAD` запросы ко всем бэкендам.
            ii. Вернуть ответ от первого успешно ответившего, отменив остальные запросы через `context.CancelFunc`.
            iii. Сообщить `ReportSuccess` для "победившего" бэкенда. Остальные отмененные запросы не требуют репорта.
        *   **`"newest"`**:
            i. **Фаза 1**: Запустить параллельные `HEAD` запросы ко всем бэкендам. Дождаться всех ответов.
            ii. Для каждого ответа вызвать `ReportSuccess` или `ReportFailure`.
            iii. **Фаза 2**: Сравнить `Last-Modified` у всех успешных ответов и выбрать бэкенд с самым новым объектом.
            iv. **Фаза 3**: Выполнить один целевой `GET`/`HEAD` запрос только к этому бэкенду. Сообщить о его результате.
    c. Вернуть `S3Response`, полученный от бэкенда. Тело ответа (`io.ReadCloser`) должно передаваться напрямую без буферизации.
    d. Если ни один бэкенд не вернул успешный ответ, сформировать итоговую ошибку (например, `404 Not Found`, если все бэкенды вернули 404).

**B. `ListObjects(ctx, req)`**

1.  **Пагинация**: Декодировать `ProxyContinuationToken` из запроса, чтобы получить индивидуальные токены для каждого бэкенда.
2.  **Запросы**: Запросить "живые" бэкенды. Запустить параллельные `ListObjectsV2` запросы ко всем.
3.  **Сбор результатов**: Собрать все ответы от бэкендов. Для каждого ответа вызвать `ReportSuccess`/`ReportFailure`.
4.  **Слияние**: Объединить полученные списки объектов в один, удаляя дубликаты по ключу и оставляя самую новую версию объекта (сравнивая `Last-Modified`).
5.  **Формирование ответа**:
    a. Создать итоговый список объектов.
    b. Сформировать новый `ProxyContinuationToken` на основе `NextContinuationToken` из всех ответов бэкендов.
    c. Установить флаг `IsTruncated=true`, если он был `true` хотя бы в одном из ответов.
    d. Вернуть `S3Response`, содержащий XML с объединенными данными.

#### 5. Сбор метрик

Внутри методов `Fetcher` должны быть вызовы к интерфейсу `f.metrics`:

*   После каждого запроса к бэкенду (успешного, неуспешного или отмененного) измерять его длительность и вызывать `f.metrics.ObserveBackendRequestLatency(...)`.
*   Также вызывать `f.metrics.IncrementBackendRequestsTotal(...)` с соответствующим результатом (`"success"`, `"error"`).
*   Для `GET`-запросов, при передаче тела ответа клиенту, оборачивать `io.Reader` в счетчик байт и по завершении вызывать `f.metrics.AddBackendBytesRead(...)`.

#### 6. Ответственность разработчика

1.  Реализовать структуру `Fetcher` и ее конструктор `NewFetcher`.
2.  Реализовать интерфейс `FetchingExecutor`, включая методы `GetObject`, `HeadObject`, `ListObjects`.
3.  Четко следовать логике, описанной в п.4, для каждой операции. Особое внимание уделить корректной обработке `context` для отмены запросов и потоковой передаче данных.
4.  Реализовать сложную логику слияния и пагинации для `ListObjects`.
5.  На протяжении всей реализации использовать только определенные интерфейсы (`BackendProvider`, `Cache`, `Metrics`) для взаимодействия с другими модулями.
6.  Интегрировать сбор метрик производительности бэкендов, вызывая методы интерфейса `Metrics`.
7.  Написать unit-тесты, которые мокируют (`mock`) все три интерфейса зависимостей (`BackendProvider`, `Cache`, `Metrics`). Тесты должны проверять:
    *   Корректную работу обеих стратегий (`first` и `newest`).
    *   Правильность логики слияния списков `LIST`.
    *   Что модуль правильно вызывает методы `ReportSuccess`/`ReportFailure` у `BackendProvider`.
    *   Что модуль вызывает `cache.Get` в начале `GetObject`/`HeadObject`.
    *   Что модуль корректно вызывает методы для обновления метрик.