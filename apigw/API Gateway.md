### Техническое Задание: Модуль API Gateway

#### 1. Назначение и Зона ответственности

Модуль **API Gateway** является единственной точкой входа для всех S3-клиентов. Его основная задача — принять входящий HTTP-запрос, преобразовать его в стандартизированное внутреннее представление S3-операции и передать на обработку в следующий модуль — **Policy & Routing Engine**.

**Ключевые обязанности:**
*   Прослушивание сетевого порта (HTTP и/или HTTPS).
*   Парсинг URL, заголовков и параметров запроса для определения типа S3-операции, целевого бакета и ключа объекта.
*   Преобразование сырого `http.Request` в структурированный объект `S3Request`, который будет использоваться во всей остальной части приложения.
*   Передача `S3Request` на обработку единому обработчику (`RequestHandler`).
*   Получение стандартизированного объекта ответа `S3Response` от обработчика.
*   Форматирование и отправка финального HTTP-ответа клиенту на основе `S3Response`, включая код состояния, заголовки и тело ответа.

**Вне зоны ответственности модуля:**
*   Бизнес-логика обработки запросов (репликация, чтение, кэширование).
*   Аутентификация и авторизация (он только извлекает данные для аутентификации, например, заголовок `Authorization`, но не проверяет их).
*   Управление бэкендами.

#### 2. Основные компоненты

Модуль состоит из следующих логических частей:

1.  **HTTP Listener**: На базе стандартной библиотеки `net/http`. Отвечает за запуск сервера, обработку TLS и управление таймаутами соединений.
2.  **Request Parser**: Ключевой компонент. Анализирует входящий `*http.Request` и извлекает из него всю S3-специфичную информацию.
3.  **Request Dispatcher**: Главный маршрутизатор. После парсинга он вызывает единственный метод интерфейса `RequestHandler`, передавая ему созданный `S3Request`.
4.  **Response Writer**: Получает `S3Response` от `RequestHandler` и формирует из него конечный `http.ResponseWriter` ответ клиенту.

#### 3. Парсинг входящего S3-запроса

`Request Parser` должен уметь обрабатывать S3-запросы в формате **Path-Style** (`http://s3.example.com/bucket-name/key-name`). Поддержка Virtual-Hosted-Style (`http://bucket-name.s3.example.com/key-name`) является опциональной для первой версии.

**Парсер должен извлекать:**

1.  **Бакет (Bucket)**: Первая часть пути URL. Например, из `/my-precious-bucket/photos/2023/cat.jpg` он должен извлечь `my-precious-bucket`.
2.  **Ключ объекта (Object Key)**: Всё, что идёт после бакета в пути. Из примера выше — `photos/2023/cat.jpg`.
3.  **Тип операции (Operation)**: Определяется на основе HTTP-метода и query-параметров.

| HTTP Метод | Query Параметры | Определяемая операция | Примечание |
| :--- | :--- | :--- | :--- |
| `PUT` | (нет) | `PUT_OBJECT` | Загрузка объекта. |
| `GET` | (нет) | `GET_OBJECT` | Скачивание объекта. |
| `HEAD` | (нет) | `HEAD_OBJECT` | Получение метаданных объекта. |
| `DELETE` | (нет) | `DELETE_OBJECT` | Удаление объекта. |
| `GET` | (нет, путь вида `/bucket/`) | `LIST_OBJECTS_V2` | Листинг объектов (по умолчанию v2). |
| `POST` | `?uploads` | `CREATE_MULTIPART_UPLOAD` | Инициация мультипарт-загрузки. |
| `PUT` | `?partNumber=N&uploadId=...`| `UPLOAD_PART` | Загрузка части. |
| `POST` | `?uploadId=...` | `COMPLETE_MULTIPART_UPLOAD`| Завершение мультипарт-загрузки. |
| `DELETE` | `?uploadId=...` | `ABORT_MULTIPART_UPLOAD` | Отмена мультипарт-загрузки. |
| `GET` | `?uploads` | `LIST_MULTIPART_UPLOADS` | Список активных мультипарт-загрузок. |
| `GET` | (нет, путь вида `/`) | `LIST_BUCKETS` | Список бакетов. |

4.  **Заголовки (Headers)**: Все `x-amz-*` заголовки, а также стандартные HTTP-заголовки, критичные для S3, должны быть сохранены и переданы дальше. Особенно важны:
    *   `Authorization`: Для последующей аутентификации.
    *   `Content-Length`
    *   `Content-MD5`
    *   `Content-Type`
    *   `x-amz-content-sha256`
    *   `x-amz-meta-*`: Пользовательские метаданные.

5.  **Тело запроса (Body)**: Тело запроса должно передаваться как есть, в виде потока (`io.ReadCloser`), чтобы избежать его полного считывания в память в данном модуле.

#### 4. Взаимодействие с другими модулями и интерфейсы (Go)

Для обеспечения модульности и слабой связанности, взаимодействие должно осуществляться через Go-интерфейсы.

**1. Внутренние структуры данных:**

```go
// S3Operation определяет тип S3 операции.
type S3Operation int

const (
    // Определяем константы для всех поддерживаемых операций
    UnsupportedOperation S3Operation = iota
    PutObject
    GetObject
    HeadObject
    DeleteObject
    ListObjectsV2
    // ... и так далее для всех multipart операций и ListBuckets
    CreateMultipartUpload
    UploadPart
    CompleteMultipartUpload
    AbortMultipartUpload
    ListMultipartUploads
    ListBuckets
)

// S3Request - это стандартизированное внутреннее представление S3-запроса.
// Создается модулем API Gateway из http.Request.
type S3Request struct {
    // Тип операции, определенный парсером.
    Operation S3Operation

    // Имя бакета, извлеченное из URL.
    Bucket string

    // Ключ объекта, извлеченный из URL.
    Key string

    // Оригинальные заголовки HTTP запроса.
    Headers http.Header

    // Оригинальные query-параметры запроса.
    Query url.Values

    // Тело запроса для операций PUT, POST.
    // Передается как есть для потоковой обработки.
    Body io.ReadCloser

    // Размер тела запроса, из заголовка Content-Length.
    ContentLength int64
    
    // Оригинальный контекст запроса для поддержки таймаутов и отмены.
    Context context.Context
}

// S3Response - это стандартизированное внутреннее представление ответа.
// Формируется нижележащими модулями и используется API Gateway для отправки ответа.
type S3Response struct {
    // HTTP код состояния для отправки клиенту (например, 200, 404, 500).
    StatusCode int

    // Заголовки для отправки клиенту.
    Headers http.Header

    // Тело ответа для отправки клиенту.
    // Должно быть потоком для эффективной передачи больших объектов.
    Body io.ReadCloser

    // Ошибка, возникшая при обработке. Если не nil, Body игнорируется.
    // Используется для формирования стандартного S3 XML-ответа об ошибке.
    Error error 
}
```

**2. Интерфейс обработчика:**

API Gateway будет содержать один экземпляр, реализующий следующий интерфейс:

```go
// RequestHandler - это интерфейс, который должен реализовывать
// следующий по цепочке модуль (Policy & Routing Engine).
type RequestHandler interface {
    // Handle принимает распарсенный S3Request и выполняет всю бизнес-логику,
    // возвращая S3Response, готовый для отправки клиенту.
    Handle(req *S3Request) *S3Response
}
```

#### 5. Жизненный цикл запроса (внутри модуля)

1.  **Прием**: `http.ListenAndServe()` принимает новый запрос, создается `*http.Request` и `http.ResponseWriter`.
2.  **Диспетчеризация**: Главный HTTP-обработчик (`http.HandlerFunc`) модуля получает запрос.
3.  **Парсинг**:
    *   Создается пустой `S3Request`.
    *   Вызывается `RequestParser`, который анализирует `*http.Request` и заполняет поля `S3Request` (Bucket, Key, Operation, Headers, etc.).
    *   Если парсинг не удался (например, некорректный URL), немедленно формируется `S3Response` с кодом `400 Bad Request` и XML-ошибкой и переходим к шагу 6.
4.  **Передача управления**: Вызывается метод `requestHandler.Handle(s3Request)`. Выполнение в текущей горутине блокируется до получения ответа. `s3Request.Context` передается для возможности отмены операции извне (например, если клиент закрыл соединение).
5.  **Получение результата**: `requestHandler.Handle` возвращает `*S3Response`.
6.  **Отправка ответа**:
    *   Вызывается `ResponseWriter`.
    *   Он копирует заголовки из `s3Response.Headers` в `http.ResponseWriter`.
    *   Устанавливает код ответа `http.ResponseWriter.WriteHeader(s3Response.StatusCode)`.
    *   Если `s3Response.Body` не `nil`, его содержимое копируется (`io.Copy`) в `http.ResponseWriter`. Это обеспечивает потоковую передачу ответа без буферизации в памяти.
    *   Если `s3Response.Body` это `io.ReadCloser`, необходимо вызвать `Close()` после копирования.

#### 6. Конфигурация модуля

Модуль должен принимать следующие параметры конфигурации:

*   `listen_address`: Адрес и порт для прослушивания (например, `:9000`).
*   `tls_cert_file`: Путь к файлу SSL-сертификата (опционально, для включения HTTPS).
*   `tls_key_file`: Путь к файлу приватного ключа SSL (опционально).
*   `read_timeout`: Таймаут на чтение всего запроса, включая тело.
*   `write_timeout`: Таймаут на запись всего ответа.

#### 7. Ответственность разработчика

Разработчик, реализующий данный модуль, должен:

1.  Создать Go-файл(ы) для модуля `apigw`.
2.  Реализовать функцию `NewServer(config Config, handler RequestHandler) *http.Server`, которая инициализирует и возвращает сконфигурированный, но не запущенный `*http.Server`.
3.  Реализовать основной `http.HandlerFunc`, который выполняет шаги из раздела "Жизненный цикл запроса".
4.  Реализовать детальную логику парсера, который корректно определяет все перечисленные в п.3 S3-операции.
5.  Написать unit-тесты, покрывающие логику парсера для всех типов операций и различных форматов URL.
6.  Предусмотреть корректную обработку ошибок на всех этапах (парсинг, запись ответа).