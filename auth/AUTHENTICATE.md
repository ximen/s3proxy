### Техническое Задание: Модуль Аутентификации (Authentication Module)

#### 1. Назначение и Зона ответственности

Модуль **Аутентификации** отвечает за проверку подлинности входящих запросов. Его главная задача — ответить на вопрос: **"Является ли этот запрос подписанным действительным, известным системе ключом?"**.

Модуль принимает стандартизированный `S3Request` от вышестоящего компонента (Policy & Routing Engine) и возвращает либо подтвержденную личность пользователя (`UserIdentity`), либо ошибку аутентификации.

**Ключевые обязанности:**
*   Реализация механизма проверки подписи **AWS Signature Version 4 (SigV4)**, который является стандартом для S3.
*   Извлечение аутентификационных данных из `S3Request` (в частности, из заголовка `Authorization`).
*   Проверка существования предоставленного `Access Key` в своей базе данных (в начальной реализации — в статическом списке).
*   Вычисление серверной версии подписи запроса и её сравнение с подписью, предоставленной клиентом.
*   Формирование структурированного ответа — либо `UserIdentity`, либо специфическая ошибка (`InvalidAccessKeyId`, `SignatureDoesNotMatch` и т.д.).

**Вне зоны ответственности модуля:**
*   **Авторизация**: Модуль не решает, имеет ли пользователь право выполнять запрошенную операцию (например, `PUT` в определенный бакет). Он только подтверждает, кто этот пользователь.
*   **Парсинг HTTP**: Модуль не работает напрямую с `http.Request`, он получает уже готовый `S3Request`.
*   **Управление сессиями или токенами**: Вся аутентификация происходит на основе каждого отдельного запроса по протоколу SigV4.

#### 2. Интерфейсы и структуры данных (Go)

Ключ к заменяемости — это четко определенный интерфейс. Любой будущий механизм аутентификации (Vault, IAM Passthrough, JWT) должен будет реализовать этот же интерфейс.

**1. Основной интерфейс аутентификатора:**

```go
// Authenticator - это универсальный интерфейс для всех модулей аутентификации.
type Authenticator interface {
    // Authenticate проверяет подлинность запроса.
    // На вход получает S3Request, так как для вычисления подписи SigV4
    // необходимы данные всего запроса (метод, URL, заголовки, хэш тела).
    // Возвращает подтвержденную личность пользователя или ошибку аутентификации.
    Authenticate(req *S3Request) (*UserIdentity, error)
}
```

**2. Структура идентификации пользователя:**

```go
// UserIdentity представляет подтвержденную личность пользователя.
// Эта структура будет передаваться дальше в модуль авторизации.
type UserIdentity struct {
    // Уникальный идентификатор пользователя, он же ключ доступа.
    AccessKey string

    // Отображаемое имя пользователя (опционально, для логов и UI).
    DisplayName string

    // Можно добавить другие поля для будущих нужд, например, список ролей.
    // Roles []string
}
```

**3. Пользовательские ошибки для точной диагностики:**

Для того чтобы вышестоящий модуль мог сформировать корректный XML-ответ об ошибке S3, модуль аутентификации должен возвращать типизированные ошибки.

```go
import "errors"

var (
    // ErrMissingAuthHeader - отсутствует заголовок Authorization.
    ErrMissingAuthHeader = errors.New("missing authorization header")
    // ErrInvalidAuthHeader - некорректный формат заголовка Authorization.
    ErrInvalidAuthHeader = errors.New("invalid authorization header")
    // ErrInvalidAccessKeyID - предоставленный Access Key не найден в системе.
    ErrInvalidAccessKeyID = errors.New("invalid access key ID")
    // ErrSignatureMismatch - вычисленная подпись не совпадает с предоставленной.
    ErrSignatureMismatch = errors.New("signature does not match")
    // ErrRequestExpired - временная метка запроса находится за пределами допустимого окна.
    ErrRequestExpired = errors.New("request has expired")
)
```

#### 3. Начальная реализация: `StaticAuthenticator`

Это конкретная реализация интерфейса `Authenticator`, которая использует статически заданный список ключей.

**1. Структура `StaticAuthenticator`:**

```go
// SecretKey представляет секретный ключ и связанные с ним данные пользователя.
type SecretKey struct {
    SecretAccessKey string
    DisplayName     string
}

// StaticAuthenticator реализует интерфейс Authenticator,
// используя для проверки map[accessKey]secretKey.
type StaticAuthenticator struct {
    // credentials - это потокобезопасная карта для хранения ключей.
    // Используется sync.Map или map с мьютексом для безопасного чтения.
    credentials map[string]SecretKey
    
    // ...могут быть добавлены логгер или другие зависимости
}

// NewStaticAuthenticator создает новый экземпляр аутентификатора.
func NewStaticAuthenticator(creds map[string]SecretKey) (*StaticAuthenticator, error) {
    if creds == nil || len(creds) == 0 {
        // Можно решить, является ли это ошибкой или просто "пустым" аутентификатором.
        // Для безопасности лучше считать ошибкой конфигурации.
        return nil, errors.New("credentials map cannot be nil or empty")
    }
    return &StaticAuthenticator{
        credentials: creds,
    }, nil
}
```

**2. Логика метода `Authenticate` для `StaticAuthenticator`:**

1.  **Извлечение данных**: Получить заголовок `Authorization` из `req.Headers`. Если его нет, вернуть `ErrMissingAuthHeader`.
2.  **Парсинг заголовка**: Распарсить заголовок SigV4. Он имеет сложный формат, например: `AWS4-HMAC-SHA256 Credential=AKIA.../20230101/us-east-1/s3/aws4_request, SignedHeaders=..., Signature=...`.
    *   Извлечь `AccessKey` клиента.
    *   Извлечь `Signature` клиента.
    *   Извлечь остальные компоненты, необходимые для пересчета подписи (`SignedHeaders`, дата, регион и т.д.).
    *   **Рекомендация**: Использовать готовую, проверенную библиотеку для парсинга SigV4, чтобы не допустить ошибок.
3.  **Поиск ключа**: Найти `AccessKey` клиента в `s.credentials`.
    *   Если ключ не найден, вернуть `ErrInvalidAccessKeyID`.
    *   Если найден, получить соответствующий ему `SecretAccessKey`.
4.  **Пересчет подписи (Server-Side)**:
    *   Используя `SecretAccessKey` и все данные из `S3Request` (метод, path, query, заголовки, хэш тела `x-amz-content-sha256`), полностью воспроизвести алгоритм вычисления подписи SigV4. Этот процесс включает создание "канонического запроса" и "строки для подписи".
    *   **Критически важно**: Использовать для этого шага надежную криптографическую библиотеку (например, входящую в состав AWS SDK). Самостоятельная реализация криптографии чревата уязвимостями.
5.  **Сравнение подписей**: Сравнить подпись, вычисленную на сервере, с подписью, полученной от клиента. Используйте для этого функцию, безопасную от атак по времени (`crypto/subtle.ConstantTimeCompare`).
    *   Если подписи не совпадают, вернуть `ErrSignatureMismatch`.
6.  **Успех**: Если подписи совпадают, создать и вернуть экземпляр `UserIdentity`, заполнив его данными из `s.credentials`.
    *   `return &UserIdentity{AccessKey: accessKey, DisplayName: cred.DisplayName}, nil`

#### 4. Конфигурация модуля

Конфигурация для `StaticAuthenticator` должна позволять легко задавать список пользователей. Пример в `YAML`:

```yaml
authentication:
  # Тип провайдера. В будущем можно будет указать "vault", "iam", etc.
  provider: "static"
  
  static:
    # Список пользователей и их ключей
    users:
      - access_key: "AKIAIOSFODNN7EXAMPLE"
        secret_key: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
        display_name: "backup-script-user"
      
      - access_key: "AKIAYDR45T3E2EXAMPLE"
        secret_key: "a82hdaHGTi92k/2kdldk29dGSH28skdEXAMPLEKEY"
        display_name: "admin-user"

```

Главное приложение будет читать этот конфиг, и в зависимости от `provider` создавать нужный экземпляр `Authenticator`.

#### 5. Ответственность разработчика

Разработчик, реализующий данный модуль, должен:

1.  Определить в коде интерфейс `Authenticator`, структуру `UserIdentity` и пользовательские типы ошибок.
2.  Реализовать структуру `StaticAuthenticator`, удовлетворяющую интерфейсу.
3.  Реализовать конструктор `NewStaticAuthenticator`, принимающий на вход `map` с учетными данными.
4.  Реализовать метод `Authenticate`, уделив особое внимание:
    *   Безопасному использованию проверенной библиотеки для парсинга и вычисления подписи SigV4.
    *   Корректной обработке всех пограничных случаев (отсутствие заголовка, неверный формат, неизвестный ключ).
    *   Использованию `subtle.ConstantTimeCompare` для сравнения подписей.
5.  Написать исчерпывающие unit-тесты, которые проверяют:
    *   Успешную аутентификацию с валидной подписью.
    *   Ошибку при неверной подписи.
    *   Ошибку при неизвестном `AccessKey`.
    *   Ошибку при отсутствии или некорректном заголовке `Authorization`.